# Micro Cold Spray Development Guidelines

## Overview

Expert system for Python, FastAPI, and industrial automation, focusing on a modular
service-based architecture with clear separation of concerns.

## Core Architecture

### Base Module Components

1. **BaseService**: Service lifecycle management
    * Async start/stop operations
    * Running state tracking
    * Health monitoring
    * Minimal interface for subclassing

2. **ConfigurableService**: Configuration management mixin
    * Pydantic model validation
    * Type-safe configuration
    * Runtime configuration validation
    * Service state validation

3. **ErrorHandling** (base_errors)
    * Extends FastAPI's HTTPException
    * Adds timestamps to all errors
    * Optional context dictionary
    * Exception cause chaining
    * Example:

        ```python
        raise create_error(
            status_code=status.HTTP_400_BAD_REQUEST,
            message="Invalid configuration",
            context={"service": service_name},
            cause=original_error
        )
        ```

4. **ServiceRegistry** (base_registry)
    * Service registration
    * Type-safe service lookup
    * Name-based service lookup
    * Lifecycle cleanup

5. **BaseRouter**: FastAPI router with health endpoint
    * Pydantic response models
    * Service health monitoring
    * Aggregate health status

6. **BaseApp**: FastAPI application factory
    * Service lifecycle management
    * Built-in CORS support
    * Health check endpoint
    * FastAPI dependency injection

### Component Relationships

* BaseApp manages service lifecycle via FastAPI lifespan
* ConfigurableService mixes into BaseService
* All components use FastAPI's built-in features where possible
* ServiceRegistry manages service instances
* BaseRouter provides health monitoring

### Service Architecture

1. **Service Hierarchy**
    * BaseService: Core lifecycle management
    * ConfigurableService: Optional configuration mixin
    * Specific Services: Inherit and implement core methods
        * DataCollection
        * State
        * Messaging
        * Process
        * Hardware

2. **Service Lifecycle**
    * Initialization: Basic setup
    * Configuration: Optional Pydantic model validation
    * Start: Resource acquisition
    * Operation: Service-specific tasks
    * Stop: Resource cleanup
    * Error Handling: FastAPI HTTP exceptions

3. **Service Management**
    * FastAPI dependency injection
    * Async context managers
    * Type-safe service registry
    * Health monitoring

## Development Guidelines

### Error Handling and Validation

1. **HTTP Status Codes**
    * 400 Bad Request: Client errors
    * 401 Unauthorized: Authentication required
    * 403 Forbidden: Permission denied
    * 404 Not Found: Resource doesn't exist
    * 409 Conflict: Resource state conflict
    * 422 Unprocessable Entity: Validation errors
    * 500 Internal Server Error: Unexpected errors
    * 503 Service Unavailable: Service issues

2. **Error Response Format**

    ```json
    {
        "detail": {
            "message": "Human readable error message",
            "timestamp": "ISO format timestamp",
            "context": {
                "service": "Service name or type",
                "error": "Original error message"
            }
        }
    }
    ```

3. **Error Handling Principles**
    * Use FastAPI's exception handling
    * Add timestamps and context
    * Chain original exceptions
    * Use consistent format

### Code Style

1. **Python Best Practices**
    * Leverage FastAPI features
    * Use Pydantic models
    * Type hints everywhere
    * Async/await for I/O
    * Clear naming

2. **Module Structure**
    * Minimal base classes
    * FastAPI dependency injection
    * Clear separation of concerns

### Testing Guidelines

1. **Test Structure**
    * pytest for testing
    * FastAPI test client
    * Async test support
    * Mocked services

2. **Test Organization**
    * Root fixtures in conftest.py
    * Service-specific fixtures
    * FastAPI test client fixtures

3. **Test Patterns**
    * Mock service implementations
    * FastAPI dependency overrides
    * Async test functions
    * Health check validation

### Database Guidelines

1. **Data Management**
    * PostgreSQL with asyncpg
    * YAML configuration
    * FastAPI dependency injection
    * Connection pooling

2. **File Organization**
    * Configuration in `config/`
    * Data in organized subdirectories
    * Clear separation of concerns

3. **Database Operations**
    * Async operations
    * FastAPI dependencies
    * Proper error handling
    * Transaction management

## Dependencies

* FastAPI: Core framework
* Pydantic: Data validation
* asyncpg: PostgreSQL driver
* PyYAML: Configuration
* pytest: Testing
* loguru: Logging
  