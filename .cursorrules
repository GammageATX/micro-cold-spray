# Micro Cold Spray Development Guidelines

## Core Concepts

1. **Independent Services**
    * Each service is self-contained
    * No inheritance between services
    * Clear API boundaries
    * Simple state management

2. **Error Handling**

    ```python
    from micro_cold_spray.api.base import create_error
    from fastapi import status

    raise create_error(
        status_code=status.HTTP_400_BAD_REQUEST,
        message="Invalid configuration"
    )
    ```

    Common Status Codes:
    * 400: Bad Request - Client errors
    * 404: Not Found - Resource doesn't exist
    * 409: Conflict - Resource state conflict
    * 422: Validation - Invalid input data
    * 500: Internal Error - Unexpected errors
    * 503: Unavailable - Service issues

## Service Implementation

### Basic Structure

```python
from fastapi import FastAPI, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

def create_service() -> FastAPI:
    """Create a new service instance."""
    app = FastAPI(title="Service Name")
    
    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["GET", "POST", "PUT", "DELETE"],
        allow_headers=["*"],
    )
    
    # State management
    state = {"is_running": False}
    
    @app.get("/health")
    async def health():
        return {"status": "running" if state["is_running"] else "stopped"}
    
    @app.post("/start")
    async def start():
        if state["is_running"]:
            raise create_error(
                status_code=status.HTTP_409_CONFLICT,
                message="Service already running"
            )
        state["is_running"] = True
        return {"status": "started"}
    
    return app
```

### Required Components

1. **Core Elements**
    * FastAPI application
    * Health check endpoint
    * State management
    * Error handling
    * CORS middleware

2. **State Management**
    * Simple dictionary for state
    * Clear state transitions
    * Error tracking
    * Status reporting

## Development Best Practices

### Code Style

1. **Python Standards**
    * Type hints everywhere
    * Async/await for I/O
    * Clear naming
    * Complete docstrings

2. **Service Organization**
    * One service per module
    * Clear separation of concerns
    * Minimal dependencies
    * Self-contained logic

### Testing

1. **Test Structure**

    ```python
    async def test_service_health(client):
        response = await client.get("/health")
        assert response.status_code == 200
        assert "status" in response.json()
    ```

2. **Test Organization**
    * One test file per service
    * Clear test names
    * Independent test cases
    * Proper cleanup

## Dependencies

* FastAPI: Web framework
* Pydantic: Data validation
* pytest: Testing
* httpx: HTTP client
* loguru: Logging
  