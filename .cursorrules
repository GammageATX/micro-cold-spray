# Micro Cold Spray Development Guidelines

"""Expert in Python, FastAPI, and industrial automation systems."""

Key Principles

- Write concise, technical responses with accurate Python examples
- Use clear service-based architecture with well-defined responsibilities
- Prefer modular design with clear separation of concerns
- Use descriptive variable names with auxiliary verbs (e.g., is_running, has_initialized)
- Follow consistent file naming: lowercase with underscores (e.g., data_collection/storage.py)
- Implement comprehensive test coverage for all components

Python/FastAPI

- Use async/await for I/O operations (database, external services)
- Use type hints consistently, especially for public interfaces
- Leverage Pydantic models for data validation and serialization
- Structure code into logical API modules (state, messaging, data_collection)
- Follow consistent error handling patterns across services
- Use dependency injection for service management

Error Handling and Validation

- Use standard HTTP status codes from FastAPI's status module:
  - 400 Bad Request: Client errors (invalid input, bad parameters)
  - 401 Unauthorized: Authentication required
  - 403 Forbidden: Permission denied
  - 404 Not Found: Resource doesn't exist
  - 409 Conflict: Resource state conflict
  - 422 Unprocessable Entity: Validation errors
  - 500 Internal Server Error: Unexpected server errors
  - 503 Service Unavailable: Service not ready/available

Dependencies

- FastAPI for API framework
- Pydantic for data validation
- asyncpg for PostgreSQL/TimescaleDB
- pytest for testing
- loguru for logging

Service Architecture

- Base services inherit from BaseService/ConfigurableService
- Each service handles specific functionality (DataCollection, State, Messaging)
- Services manage their own lifecycle (initialize, start, stop)
- Use async context managers for resource management
- Implement proper cleanup in service shutdown

Database Guidelines

- Use TimescaleDB for time-series data
- Implement proper connection pooling
- Use parameterized queries to prevent SQL injection
- Handle database errors gracefully
- Clean up connections and resources properly

Testing Guidelines

- Use pytest for testing, handle warings by looking up website provided by pytest
- Write comprehensive unit tests for all components
- Use pytest fixtures for test setup/teardown
- Mock external dependencies appropriately
- Test both success and error paths
- Ensure proper database cleanup between tests
- Use proper async test patterns

Performance Considerations

- Use connection pooling for database operations
- Implement proper caching strategies
- Handle concurrent operations safely
- Monitor and optimize database queries
- Use appropriate batch operations when possible

Refer to project documentation for specific implementation details and patterns.
  