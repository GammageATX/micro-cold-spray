# Core Architecture Rules

## Single Source of Truth (SSOT)

- TagManager: All hardware communication and tag state
- ConfigManager: All configuration management and validation
- MessageBroker: All pub/sub messaging and request handling
- UIUpdateManager: Tag update distribution to widgets
- StateManager: All system state transitions and validation
- DataManager: All process data and history

## Component Requirements

1. Hardware Communication:
   - Only TagManager can use hardware clients
   - Must handle connection failures gracefully
   - Must validate all hardware operations
   - Must support mock mode for development
   - Must implement retry logic for operations

2. UI Components:
   - Must inherit from BaseWidget
   - Must register with UIUpdateManager for tag updates only
   - Must implement async cleanup
   - Must use Qt6 enum classes
   - Must handle state changes properly
   - Must validate user inputs
   - Must provide clear error feedback
   - Must support keyboard shortcuts
   - Must follow accessibility guidelines
   - Must handle own error states
   - Must communicate directly with MessageBroker for pub/sub
   - Must manage own widget state

3. Error Handling:
   - Each component handles its own errors
   - Must catch and log all exceptions
   - Must provide context in error messages
   - Must handle async operations properly
   - Must implement recovery procedures
   - Must maintain system safety
   - Must log error details for debugging

4. Process Validation:
   - Must validate all process parameters
   - Must check safety conditions
   - Must verify hardware states
   - Must validate motion limits
   - Must check gas flow conditions
   - Must verify vacuum levels
   - Must validate pattern bounds

## Development Standards

1. Code Style:
   - Follow PEP 8
   - Use type hints
   - Document public interfaces
   - Keep methods focused and small
   - Use meaningful variable names
   - Add comments for complex logic
   - Use constants for magic numbers
   - Follow SOLID principles

2. Testing:
   - Write unit tests for new features
   - Mock hardware dependencies
   - Test error conditions
   - Verify message patterns
   - Include integration tests
   - Test UI interactions
   - Test state transitions
   - Verify data persistence
   - Test configuration changes

3. Dependencies:
   - Document in requirements.txt
   - Pin major versions
   - Use virtual environment
   - Minimize external dependencies
   - Document dependency purposes
   - Check for security updates
   - Test version compatibility

4. Documentation:
   - Document all public APIs
   - Include usage examples
   - Document configuration options
   - Maintain change log
   - Document error codes
   - Include troubleshooting guides
   - Document safety procedures

5. Version Control:
   - Use descriptive commit messages
   - Create feature branches
   - Review before merging
   - Tag releases
   - Update change log
   - Follow semantic versioning
   - Document breaking changes
