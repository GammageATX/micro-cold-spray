{% extends "base.html" %}
{% block content %}
<div class="panel">
    <h2>Tag Monitor</h2>
    <div class="control-group">
        <h3>Write Tag</h3>
        <form id="write-tag-form">
            <input name="tag_path" placeholder="Tag Path" required pattern="[a-zA-Z0-9_/]+" title="Only letters, numbers, underscores, and forward slashes allowed">
            <input name="value" placeholder="Value" required>
            <button type="submit">Write</button>
        </form>
        <div id="connection-status" class="status-message"></div>
    </div>
    <div class="control-group">
        <h3>Monitor Tags</h3>
        <select id="tag-group">
            <option value="">All Groups</option>
            <option value="gas_control">Gas Control</option>
            <option value="motion">Motion</option>
            <option value="hardware_sets">Hardware Sets</option>
        </select>
        <div id="tag-values"></div>
    </div>
</div>

<script>
let ws = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 5000;

document.getElementById('write-tag-form').onsubmit = async (e) => {
    e.preventDefault();
    const form = e.target;
    const value = form.value.value;

    // Validate value based on type
    try {
        const parsedValue = parseTagValue(value);
        
        const response = await fetch(`${API_URLS.communication}/tags/write`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                tag_path: form.tag_path.value,
                value: parsedValue
            })
        });
        if (!response.ok) throw await response.json();
        showSuccess('Tag written successfully');
        form.reset();
    } catch (error) {
        showError(error.detail || error.message || 'Failed to write tag');
    }
};

function parseTagValue(value) {
    // Try to parse as number first
    if (!isNaN(value) && value.trim() !== '') {
        return Number(value);
    }
    // Check for boolean
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;
    // Return as string if no other type matches
    return value;
}

function connectWebSocket() {
    if (ws && ws.readyState === WebSocket.OPEN) return;

    ws = new WebSocket(`${API_URLS.communication}/ws/tags`);
    updateConnectionStatus('Connecting...', 'connecting');

    ws.onopen = () => {
        console.log('WebSocket connected');
        updateConnectionStatus('Connected', 'connected');
        reconnectAttempts = 0;
    };

    ws.onclose = () => {
        console.log('WebSocket disconnected');
        updateConnectionStatus('Disconnected', 'disconnected');
        ws = null;

        // Attempt to reconnect
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            updateConnectionStatus(`Reconnecting (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'connecting');
            setTimeout(connectWebSocket, RECONNECT_DELAY);
        } else {
            updateConnectionStatus('Connection failed. Please refresh the page.', 'error');
        }
    };

    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        updateConnectionStatus('Connection error', 'error');
    };

    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            updateTagValues(data);
        } catch (error) {
            console.error('Error processing message:', error);
        }
    };
}

function updateConnectionStatus(message, status) {
    const statusElement = document.getElementById('connection-status');
    statusElement.textContent = message;
    statusElement.className = `status-message ${status}`;
}

function updateTagValues(data) {
    const container = document.getElementById('tag-values');
    const group = document.getElementById('tag-group').value;
    
    // Filter by group if selected
    const tags = group ? 
        Object.entries(data).filter(([path]) => path.startsWith(group)) :
        Object.entries(data);
        
    container.innerHTML = tags.map(([path, value]) => `
        <div class="tag-value">
            <span class="tag-path">${path}</span>
            <span class="tag-value ${typeof value === 'boolean' ? value ? 'true' : 'false' : ''}">${value}</span>
        </div>
    `).join('');
}

// Add styles
const style = document.createElement('style');
style.textContent = `
.status-message {
    margin-top: 1rem;
    padding: 0.5rem;
    border-radius: 4px;
    text-align: center;
}

.status-message.connecting {
    background: #fff3cd;
    color: #856404;
}

.status-message.connected {
    background: #d4edda;
    color: #155724;
}

.status-message.disconnected {
    background: #f8d7da;
    color: #721c24;
}

.status-message.error {
    background: #f8d7da;
    color: #721c24;
}

.tag-value {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    background: #f8f9fa;
    margin-bottom: 0.25rem;
    border-radius: 4px;
}

.tag-path {
    font-family: monospace;
    color: #495057;
}

.tag-value span.true {
    color: #28a745;
}

.tag-value span.false {
    color: #dc3545;
}

#write-tag-form {
    display: grid;
    grid-template-columns: 2fr 1fr auto;
    gap: 0.5rem;
    align-items: start;
}

#write-tag-form input {
    padding: 0.5rem;
    border: 1px solid #ced4da;
    border-radius: 4px;
}

#write-tag-form button {
    padding: 0.5rem 1rem;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#write-tag-form button:hover {
    opacity: 0.9;
}
`;
document.head.appendChild(style);

// Initialize WebSocket connection
connectWebSocket();

// Add group change handler
document.getElementById('tag-group').onchange = () => {
    const container = document.getElementById('tag-values');
    container.innerHTML = '<div class="status-message">Waiting for updates...</div>';
};
</script>
{% endblock %}