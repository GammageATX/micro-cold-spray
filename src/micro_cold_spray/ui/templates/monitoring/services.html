{% extends "base.html" %}
{% block content %}
<div class="panel">
    <h2>Service Monitor</h2>
    <div class="control-group">
        <h3>Service Status</h3>
        <div id="service-list" class="service-grid"></div>
    </div>
    
    <div class="control-group">
        <h3>Service Logs</h3>
        <div id="service-logs" class="log-display">
            <div class="log-status">Connecting to log stream...</div>
        </div>
    </div>
</div>

<script>
// Service status updates
let updateInterval;
let isUpdating = false;

async function updateServices() {
    if (isUpdating) return;
    isUpdating = true;
    
    try {
        const response = await fetch('/monitoring/services/status');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const services = await response.json();
        
        const serviceList = document.getElementById('service-list');
        const currentCards = new Map(
            Array.from(serviceList.children)
                .filter(el => el.id.startsWith('service-'))
                .map(el => [el.id.replace('service-', ''), el])
        );
        
        // Update or add services
        for (const service of Object.values(services)) {
            const cardId = `service-${service.name}`;
            const existingCard = currentCards.get(service.name);
            
            if (existingCard) {
                // Update existing card if data changed
                if (hasDataChanged(existingCard, service)) {
                    const newCard = createServiceCard(service);
                    existingCard.replaceWith(newCard);
                }
            } else {
                // Add new card
                serviceList.insertAdjacentHTML('beforeend', createServiceCard(service));
            }
            currentCards.delete(service.name);
        }
        
        // Remove obsolete cards
        currentCards.forEach(card => card.remove());
        
    } catch (error) {
        console.error('Failed to update services:', error);
        showError(`Failed to update services: ${error.message}`);
    } finally {
        isUpdating = false;
    }
}

function hasDataChanged(card, service) {
    return (
        card.dataset.status !== service.status ||
        card.dataset.uptime !== service.uptime ||
        card.dataset.memory !== service.memory_usage ||
        card.dataset.version !== service.version
    );
}

function createServiceCard(service) {
    const info = service.service_info || {};
    const isRunning = info.running === true;
    const status = service.status || 'unknown';
    
    return `
        <div id="service-${service.name}" 
             class="service-card ${status}"
             data-status="${status}"
             data-uptime="${service.uptime}"
             data-memory="${service.memory_usage}"
             data-version="${info.version || ''}">
            <div class="service-header">
                <div class="service-title">
                    <h4>${service.name}</h4>
                    ${info.version ? `<span class="version">v${info.version}</span>` : ''}
                </div>
                <span class="status-badge">${status}</span>
            </div>
            <div class="service-details">
                <p><i class="fas fa-network-wired"></i> Port: ${service.port}</p>
                <p><i class="fas fa-clock"></i> Uptime: ${formatUptime(service.uptime)}</p>
                <p><i class="fas fa-memory"></i> Memory: ${formatMemoryUsage(service.memory_usage)}</p>
                ${info.error ? `<p class="error"><i class="fas fa-exclamation-triangle"></i> ${info.error}</p>` : ''}
            </div>
            <div class="service-controls">
                ${isRunning ? 
                    `<button onclick="controlService('${service.name}', 'stop')" class="stop-btn">
                        <i class="fas fa-stop"></i> Stop
                    </button>
                     <button onclick="controlService('${service.name}', 'restart')" class="restart-btn">
                        <i class="fas fa-sync"></i> Restart
                     </button>` :
                    `<button onclick="controlService('${service.name}', 'start')" class="start-btn">
                        <i class="fas fa-play"></i> Start
                     </button>`
                }
            </div>
        </div>
    `;
}

// Service control with proper error handling and visual feedback
async function controlService(serviceName, action) {
    const button = event.target.closest('button');
    if (!button) return;
    
    const card = button.closest('.service-card');
    const controls = card.querySelector('.service-controls');
    const statusBadge = card.querySelector('.status-badge');
    const originalStatus = statusBadge.textContent;
    
    try {
        // Disable controls and show loading state
        controls.querySelectorAll('button').forEach(btn => btn.disabled = true);
        card.classList.add('updating');
        statusBadge.textContent = 'Updating...';
        
        const response = await fetch('/monitoring/services/control', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ service: serviceName, action })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail?.message || `Failed to ${action} service`);
        }
        
        // Update immediately and start polling for status changes
        await updateServices();
        pollServiceStatus(serviceName);
        
    } catch (error) {
        console.error('Service control error:', error);
        showError(error.message);
        
        // Restore original state
        statusBadge.textContent = originalStatus;
        card.classList.remove('updating');
        controls.querySelectorAll('button').forEach(btn => btn.disabled = false);
    }
}

// Poll service status after control action
async function pollServiceStatus(serviceName, attempts = 30) {
    const interval = setInterval(async () => {
        try {
            const response = await fetch('/monitoring/services/status');
            if (!response.ok) throw new Error('Failed to get service status');
            
            const services = await response.json();
            const service = services[serviceName];
            
            if (service && service.status !== 'updating') {
                clearInterval(interval);
                updateServices();
            }
        } catch (error) {
            console.error('Status poll error:', error);
            clearInterval(interval);
        }
        
        if (--attempts <= 0) {
            clearInterval(interval);
            updateServices();
        }
    }, 1000);
}

// WebSocket for log updates with reconnection
let ws;
let wsReconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;

function setupWebSocket() {
    const logDisplay = document.getElementById('service-logs');
    const statusDiv = logDisplay.querySelector('.log-status');
    
    try {
        ws = new WebSocket(`ws://${window.location.host}/ws/logs`);
        
        ws.onopen = () => {
            statusDiv.textContent = 'Connected to log stream';
            statusDiv.classList.remove('error');
            wsReconnectAttempts = 0;
        };
        
        ws.onmessage = (event) => {
            const log = JSON.parse(event.data);
            addLogEntry(log);
            statusDiv.style.display = 'none';
        };
        
        ws.onclose = () => {
            statusDiv.textContent = 'Disconnected from log stream';
            statusDiv.classList.add('error');
            statusDiv.style.display = 'block';
            
            if (wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                wsReconnectAttempts++;
                setTimeout(setupWebSocket, 5000);
            }
        };
        
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            statusDiv.textContent = 'Error connecting to log stream';
            statusDiv.classList.add('error');
        };
        
    } catch (error) {
        console.error('WebSocket setup error:', error);
        statusDiv.textContent = 'Failed to connect to log stream';
        statusDiv.classList.add('error');
    }
}

function addLogEntry(log) {
    const logDisplay = document.getElementById('service-logs');
    const entry = document.createElement('div');
    entry.className = `log-entry ${log.level.toLowerCase()}`;
    entry.innerHTML = `
        <span class="timestamp">${new Date(log.timestamp).toLocaleString()}</span>
        <span class="service">${log.service}</span>
        <span class="level">${log.level}</span>
        <span class="message">${log.message}</span>
    `;
    
    logDisplay.appendChild(entry);
    
    // Keep last 100 entries
    while (logDisplay.children.length > 101) { // +1 for status div
        logDisplay.removeChild(logDisplay.children[1]); // Skip status div
    }
    
    logDisplay.scrollTop = logDisplay.scrollHeight;
}

// Utility functions
function formatMemoryUsage(bytes) {
    if (!bytes || bytes === 'N/A') return 'N/A';
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(1)} MB`;
}

function formatUptime(seconds) {
    if (!seconds || seconds === 'N/A') return 'N/A';
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${minutes}m`;
}

// Initialize
function initMonitor() {
    updateServices();
    setupWebSocket();
    startUpdates();
}

function startUpdates() {
    updateInterval = setInterval(updateServices, 5000);
}

function stopUpdates() {
    clearInterval(updateInterval);
    if (ws) ws.close();
}

// Event listeners
document.addEventListener('DOMContentLoaded', initMonitor);
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        stopUpdates();
    } else {
        startUpdates();
    }
});
window.addEventListener('unload', stopUpdates);
</script>

<style>
.service-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
    padding: 20px 0;
}

.service-card {
    background: white;
    border-radius: 4px;
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    transition: all 0.3s ease;
}

.service-card.updating {
    opacity: 0.7;
    pointer-events: none;
}

.service-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.service-title {
    display: flex;
    align-items: center;
    gap: 10px;
}

.service-title h4 {
    margin: 0;
    font-size: 1.1em;
}

.version {
    font-size: 0.8em;
    color: #666;
    padding: 2px 6px;
    background: #eee;
    border-radius: 10px;
}

.status-badge {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.8em;
    font-weight: bold;
    color: white;
}

.service-details {
    flex-grow: 1;
    font-size: 0.9em;
}

.service-details p {
    margin: 5px 0;
    display: flex;
    align-items: center;
    gap: 8px;
}

.service-details i {
    width: 16px;
    color: #666;
}

.service-controls {
    margin-top: 10px;
    display: flex;
    gap: 8px;
}

.service-controls button {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    transition: opacity 0.2s;
}

.service-controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.start-btn { background: var(--success-color); }
.stop-btn { background: var(--error-color); }
.restart-btn { background: var(--primary-color); }

/* Status colors */
.service-card.ok { border-left: 4px solid var(--success-color); }
.service-card.error { border-left: 4px solid var(--error-color); }
.service-card.unknown { border-left: 4px solid #6c757d; }

.ok .status-badge { background: var(--success-color); }
.error .status-badge { background: var(--error-color); }
.unknown .status-badge { background: #6c757d; }

/* Log display */
.log-display {
    height: 300px;
    overflow-y: auto;
    background: #1e1e1e;
    color: #d4d4d4;
    padding: 10px;
    font-family: monospace;
    border-radius: 4px;
    position: relative;
}

.log-status {
    padding: 8px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    margin-bottom: 8px;
    text-align: center;
}

.log-status.error {
    background: rgba(255, 0, 0, 0.1);
    color: #ff6b6b;
}

.log-entry {
    padding: 2px 0;
    border-bottom: 1px solid #333;
    font-size: 0.9em;
    line-height: 1.4;
}

.log-entry .timestamp { color: #569cd6; }
.log-entry .service { color: #4ec9b0; margin: 0 10px; }
.log-entry .level { color: #ce9178; margin-right: 10px; }
.log-entry.error { color: #f44747; }
.log-entry.warning { color: #dcdcaa; }

/* Error message */
.error-message {
    background: rgba(255, 0, 0, 0.1);
    color: var(--error-color);
    padding: 8px;
    border-radius: 4px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;
}
</style>
{% endblock %} 