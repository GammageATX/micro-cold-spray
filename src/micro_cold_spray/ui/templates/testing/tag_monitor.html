{% extends "base.html" %}

{% block content %}
<div class="panel">
    <h2>Tag Cache Monitor</h2>
    <div class="control-group">
        <h3>Live Tag Values</h3>
        <div class="tag-filter">
            <select id="tag-select" onchange="filterTags()">
                <option value="">All Tags</option>
            </select>
            <select id="tag-group" onchange="filterTags()">
                <option value="">All Groups</option>
                <option value="gas_control">Gas Control</option>
                <option value="motion">Motion</option>
                <option value="pressure">Pressure</option>
                <option value="valve_control">Valve Control</option>
            </select>
        </div>
        <div id="tag-list" class="tag-list"></div>
    </div>
</div>

<script>
let tagValues = {};
let availableTags = new Set();
let messageSocket = null;

// Connect to messaging service for tag operations
function connectMessaging() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/communication/tags/subscribe`;
    messageSocket = new WebSocket(wsUrl);

    messageSocket.onopen = () => {
        console.log('Connected to tag service');
        document.getElementById('tag-list').innerHTML = '<div class="status-message">Connected to tag service...</div>';
        // Request initial tags
        requestTags();
    };

    messageSocket.onclose = () => {
        console.log('Disconnected from tag service');
        document.getElementById('tag-list').innerHTML = '<div class="status-message error">Disconnected from tag service</div>';
        // Try to reconnect after 5 seconds
        setTimeout(connectMessaging, 5000);
    };

    messageSocket.onerror = (error) => {
        console.error('Tag service error:', error);
        document.getElementById('tag-list').innerHTML = '<div class="status-message error">Error connecting to tag service</div>';
    };

    messageSocket.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'tags') {
                // Handle initial tag response
                handleInitialTags(data);
            } else if (data.type === 'update') {
                // Handle tag updates
                handleTagUpdate(data);
            }
        } catch (error) {
            console.error('Error processing message:', error);
        }
    };

    return messageSocket;
}

// Request initial tags through REST API
async function requestTags() {
    try {
        const response = await fetch('/communication/tags/cache');
        if (response.ok) {
            const data = await response.json();
            handleInitialTags(data);
        } else {
            document.getElementById('tag-list').innerHTML = '<div class="status-message error">Failed to load tags</div>';
        }
    } catch (error) {
        console.error('Error requesting tags:', error);
        document.getElementById('tag-list').innerHTML = '<div class="status-message error">Error loading tags</div>';
    }
}

// Handle initial tag response
function handleInitialTags(data) {
    if (data.tags) {
        tagValues = data.tags;
        Object.keys(data.tags).forEach(tag => {
            availableTags.add(tag);
        });
        updateTagSelect();
        updateTagDisplay();
    } else {
        document.getElementById('tag-list').innerHTML = '<div class="status-message">No tags available</div>';
    }
}

// Handle tag update message
function handleTagUpdate(data) {
    if (data.tags) {
        tagValues = { ...tagValues, ...data.tags };
        
        // Update available tags and combo box
        Object.keys(data.tags).forEach(tag => {
            if (!availableTags.has(tag)) {
                availableTags.add(tag);
                updateTagSelect();
            }
        });
        
        updateTagDisplay();
    }
}

function updateTagSelect() {
    const select = document.getElementById('tag-select');
    const currentValue = select.value;
    
    // Clear existing options except the first one
    while (select.options.length > 1) {
        select.remove(1);
    }
    
    // Add sorted tags
    Array.from(availableTags)
        .sort()
        .forEach(tag => {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            select.appendChild(option);
        });
    
    // Restore previous selection if it still exists
    if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
        select.value = currentValue;
    }
}

function updateTagDisplay() {
    const tagFilter = document.getElementById('tag-select').value.toLowerCase();
    const groupFilter = document.getElementById('tag-group').value;
    
    const tagList = document.getElementById('tag-list');
    tagList.innerHTML = Object.entries(tagValues)
        .filter(([tag]) => {
            const matchesTag = !tagFilter || tag.toLowerCase() === tagFilter;
            const matchesGroup = !groupFilter || tag.startsWith(groupFilter);
            return matchesTag && matchesGroup;
        })
        .sort(([tagA], [tagB]) => tagA.localeCompare(tagB))
        .map(([tag, value]) => `
            <div class="tag-item">
                <div class="tag-name">${tag}</div>
                <div class="tag-value ${typeof value === 'boolean' ? value ? 'true' : 'false' : ''}">${value}</div>
                <div class="tag-timestamp">${new Date().toLocaleTimeString()}</div>
            </div>
        `)
        .join('');
}

function filterTags() {
    updateTagDisplay();
}

// Add styles
const style = document.createElement('style');
style.textContent = `
.tag-filter {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
}

.tag-filter select {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: white;
}

.tag-list {
    max-height: 600px;
    overflow-y: auto;
    background: #f8f9fa;
    border-radius: 4px;
    padding: 0.5rem;
}

.tag-item {
    display: grid;
    grid-template-columns: minmax(200px, 2fr) minmax(100px, 1fr) auto;
    gap: 1rem;
    padding: 0.5rem;
    border-bottom: 1px solid #dee2e6;
    align-items: center;
}

.tag-item:last-child {
    border-bottom: none;
}

.tag-name {
    font-family: monospace;
    color: #495057;
}

.tag-value {
    font-family: monospace;
    font-weight: bold;
    text-align: right;
}

.tag-value.true {
    color: #28a745;
}

.tag-value.false {
    color: #dc3545;
}

.tag-timestamp {
    color: #6c757d;
    font-size: 0.9em;
}

.status-message {
    text-align: center;
    padding: 2rem;
    color: #6c757d;
}

.status-message.error {
    color: #dc3545;
}
`;
document.head.appendChild(style);

// Initialize
connectMessaging();
</script>
{% endblock %} 